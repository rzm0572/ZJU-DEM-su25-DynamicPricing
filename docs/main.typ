#import "template.typ": *

#show: project.with(
    theme: "lab",
    title: "Dynamic Pricing",
    course: "数据要素市场",
    name: "大作业：数据动态定价算法实现",
    author: "任朱明  李文耀  江舜尧",
    school_id: "",
    teacher: "刘金飞",
    date: "2025/07/22"
)


#outline(depth: 3)

= Introduction

== 背景

如果买家想要买数据训练人工智能，那么用买到的数据训练的模型准确率，显然就表明了数据对于买家的价值，这个价值范围在 $[0,1]$ 之间。根据常理，买的数据越多，训练出来的模型越好，所以数据数量到数据的价值应该是个单调递增的函数。

显然，不同来买数据的人训练的模型不同，他们不同数据量的价值也是不同的。

那么，作为卖家，你的手上有多个等价的数据，怎么样给不同数量的数据订价挣到最多的钱呢？

== 模型

首先，我们将完成建模工作，将本问题中需要解决的问题做一个形式化的定义。

=== 公共信息

卖家有 $N$ 个完全等价的数据点，因而买卖双方对于数据点的定价和估价只与数据点数量有关。

买家有 $m$ 种类型，第 $i$ 种类型的买家买 $n$ 个完全等价的数据点给买家带来的收益/买家的事前价值/买家的估值曲线为函数 $v_i (n)$。

这个函数显然是单调递增的，没有道理说买了更多数据训练的更差了。$v_i (0) = 0$ 也是成立的，因为不买数据买家显然没有收益。

这个函数的定义域为 ${0,1,2,dots,N}$ 文中表示为 $[N]$。值域为 $[0,1]$。

卖家知道每种买家的收益曲线，但是不知道每种买家的实际比例，或者买家根本没有分布。

=== 交易过程
一共有 T 轮交易，在第 t 次交易中，卖家会选择一个定价函数 $p_t (n)$，表示第 t 轮交易卖出 n 个数据点的价格。这轮交易中买方的类型为 $i_t$。买方会选择一个购买商品的数量，使得此时自己获得最大的利润，即买方的估值函数减去卖方估值函数 $v_i_t (n) - p_t (n)$ 在这个点最大，并且这个值为正数。

如果无法获得正的利润，即买哪个商品期望值都低于付出的钱，那么买家不会告诉卖家自己的类型，也不会购买，而当且仅当买家能获得正数的利润，买家会购买，并在完成购买后告诉卖家自己的类型。

定价函数定义域为 ${0,1,2,dots,N}$ 文中表示为 $[N]$。值域为 $[0,1]$。


=== 定义

$[N]$ ：

m-step ：一个函数 $f$ 对于 $[N]$ 到 $[0,1]$ 的单调不减函数，满足至多有 $m$ 个点 $n in {0,1,2,dots,N}, f(n+1)-f(n)>0$。

$cal(P)$ ：所有可能的定价函数的集合。

$n_(i,p)$：假设某场交易中，卖方的定价函数/曲线是 $p$，买方的类型为 $i$，那么买方会选择购买商品的数量为 $n_(i,p)$。

$q$：令买家类型的分布为 $q$，其中第 $i$ 种买家的概率为 $q_i$。


卖家卖一件商品的期望收入：$"rev"(p) = sum_(i=1)^m q_i p_i(n_(p,i))$，即按照买家类型算期望。

最优定价曲线：$p^"OPT"$

按最优定价卖一件商品期望收益：$"rev"(p^"OPT")$



=== 附加假设

==== 假设1：卖家的价格函数是平滑的

对于买家的价格函数，相近的数据量价格不会差太多：

$forall n, n' in {0,1,2,dots,N}, v_i (n + n′) - v_i (n) <= frac(L,N) n'$ 

==== 假设2：数据的效用是边际效用递减的

买的数据越多，数据越不值钱

$exists J > 0 , forall  i in {0,1,2,dots,m}, forall n in {0,1,2,dots,N}, v_i (n + 1) - v_i (n) <= frac(J,n)$

=== 任务场景

==== 随机环境

这种任务中，买家的概率分布 $q$ 是固定的，第 t 轮来买数据的买家类型是按照这个分布随机抽取的 $i_t$。

这种场景下，遗憾值为最优定价曲线总的期望收益，减去实际上这 T 轮的卖数据的历史收入。

$R_T=T dot "OPT" - sum_(t=1)^T p_t (n_(i_t,p_t))$

==== 对抗场景

这种任务中，第 t 轮来买数据的买家类型是一个预先选好的随机序列。

这种场景下，遗憾值为根据这个对手的策略选择的最优策略的期望收益减去实际的收益。

$R_T= max_(p in cal(P)) sum_(t=1)^T P(n_(i_t,p))- sum_(t=1)^T p_t (n_(i_t,p_t))$


= Paper Review
文章除了回顾过往研究以及进行了一些总结与展望，其主要内容集中于如何求出商家的最优定价策略，即让商家在不断的买卖中算出一个定价，使得自己挣到最多的钱。

文章的总体思路是先在无限个定价策略中取出少量合适且够好的定价策略，然后使用两种不同的方法通过迭代法最终获得选出的定价策略中最好的的那个。

对于不同的假设，即是否认为定价策略是平滑的，是不是有边际效用递减，文章使用的不同的定价策略挑选方法。

文章正文和附录包含了对于这些算法“为什么好”的证明。

== 选择哪些卖家的估值函数

因为显然卖家的定价曲线/函数有无穷多个，因为从 N 个自然数映射到 [0,1] 的曲线是无限多的，我们需要：

1. 用“算法”从中选择有限个简单曲线/函数，每个简单函数/曲线只有至多 $m$ 个 $f(n+1)-f(n)>0$ 的点（即 m-step 的，这就是后文用到的 m-step 的定义）。

2. 证明这些曲线够用

=== 引理 3.1：可以用简单的（m-step）函数代替所有的卖家估值函数

这个引理的内容是如果有 $m$ 种买家，对于任何一个卖家的非递减定价函数，都有 m-step 函数收益不低于这个定价函数。

证明方法在 A.1 中给出。主要的思路是构造出一个函数 $overline(p)$ ，使得 $overline(p)$ 是 m-step 的，并且 $overline(p)$ 的收益不低于原函数。思路是把没人买的数据量通通涨价，直到函数被简化为阶梯函数。

不妨让没有买数据的人买的数据量 $n_(i,p)=0$ ，买了数据的人买了 $n_(i,p)$ 个数据。我们将所有的 $n_(i,p)$ 排序，得到一个递增数列 ${n_(\(i\))}$。接着构造函数 $overline(p)$ ，若 $n_(\(i\))<n<=n_(\(i+1\))$ ，则 $overline(p)=p(n_(\(i+1\)))$ ，最后大于 $n_(\(m\))$ 的数据量的价格为 $p(N)$。感性理解就是有人买的数据量不涨价，没人买的数据量都涨价到一个有人买的数据量的价格。

这样，所有按照 $overline(p)$ 计算的数据定价除了有顾客买的数据量价格不变，价格都高于原函数。显然对于每一个买家，买没有涨价的数据收益显然不如买原来买的，不然原来就不会买这个了，对于涨价的数据量，数据没涨价都不会买涨价了更不会买了，所以顾客不会改变购买选择。由于顾客购买数据量的定价是不变的，所以我们卖出这些数据收入就没有变化。

而由于顾客只有 $m$ 种类型，所以 $overline(p)$ 至多会在 m 个点上有跳变，这是由于我们的构造方法决定的，跳变的点有且仅有顾客买数据的这至多 m 个点。所以 $overline(p)$ 至多会在 m 个点上有跳变，是 m-step 函数。

m-step 函数不只有我们构造出的 $overline(p)$ ，还可以有其他的 m-step 函数。所以必然有一收益更高的 m-step 函数能代替所有的卖家估值函数。


=== 算法1：估值函数仅符合单调递增时的选择

输入误差范围 $epsilon$，买家种类 $m$

首先用等比数列 $Z_i$ 对于卖家估值函数的值域作切分。

$Z_i={ epsilon (1+epsilon)^i, forall i=0,1,2,dots,ceil(log_(1+epsilon)frac(1,epsilon))}$

接着对每一个部分作插值进一步细化值域

$W_i = { Z_(i-1) + Z_(i-1) dot frac(epsilon k,m) }$

$W = union_{i=1}^ceil(log_(1+epsilon)frac(1,epsilon)) W_i$

然后输出 $overline(cal(P))$ ，表示所有从 ${0,1,2,dots,N}$ 到 $W$ 的 m-step 映射

=== 定理3.1：算法1选出的函数收益够高，数量也够少

对于任意买家类型分布，存在 $p in overline(P)$使得其收益 $"rev"(p) >= "OPT" - O( epsilon)$（即与最优收益的差距足够小）

集合大小满足 $|overline(P)| in tilde(O)((N/epsilon)^m)$，即选出的函数足够少。

接下来我们分三步证明这个定理：

==== 步骤 1：引理 A.1：构造离最优定价比较近的函数 $tilde(p)$


 $forall epsilon$ 存在定价函数 $tilde(p): [N] -> [epsilon, 1]$，使得 $"rev"( tilde(p)) >= "OPT" - epsilon$。

设最优定价函数 OPT 为 $p^*$。

将 $p^*$ 中价格低于 $epsilon$ 的点全部涨价到 $epsilon$，得到函数 $tilde(p)$。即 $p^*(n) = max(p^*(n), epsilon)$。

如果买家购买的数据量价格不变，那么买家带来的收益不变，但是如果买家购买的数据量价格涨价，那么即使所有买家买的数据都涨价导致买家都不买了，那么损失的期望也是 $epsilon times 1 = epsilon$，所以卖一次的期望收益最多减少 $epsilon$。即引理成立

==== 步骤 2 ：引理 A.2：有一个我们刚刚从无穷个定价函数中选出的 $overline(P)$，有一函数离刚刚构造出的 $tilde(p)$ 足够近

定理的形式化表述是：$exists p in overline(P)$，使得 $"rev"(p) >= "rev"(tilde(p)) /(1+epsilon)$


由于引理 1 ，我们可以找到一个函数 $overline(p)$ 使得 $overline(p)$ 是 m-step 的，并且 $overline(p)$ 的收益不低于原函数。我们将 $overline(p)$ 中的所有取值都下降到算法 1 中构造的 $W$ 中的最靠近的值，构造出 $p$，这个 $p$ 显然在 $overline(P)$ 中，因为本身 $overline(P)$ 中就包含了所有值域为 $W$ 的 m-step 函数，下面将证明我们构造的 $p$ 与 $tilde(p)$ 相差不大。

如果不需要下降，那么自然收益不变。如果需要下降，则由于 $W_i$ 中间的插值是 $Z_(i-1) dot frac(epsilon,m)$，且 $Z_(i)$ 是以 $(1+epsilon)$，为公比的等比数列，因而 $"rev"(tilde(p)) /(1+epsilon)$ 到 $"rev"(tilde(p))$ 之间显然会有一个 $Z_i$，那也必定有 $W$ 。

所以如果买家不改变购买数量，收益为降价之后的价格，由于这个值在 $"rev"(tilde(p)) /(1+epsilon)$ 到 $"rev"(tilde(p))$ 之间，所以期望价格大于 $"rev"(tilde(p)) /(1+epsilon)$。

那么买家会不会买更少的数据导致更小的卖家收益呢？答案是不会。因为根据 $Z$ 的构造方法，$Z_i$ 是等比数列，这导致 $Z_i$ 越大越稀疏，而 $W_i$ 是在 $Z_i$ 的基础上插值的，因而 $W_i$ 越大也会越来越稀疏。而数据卖的越多价格越贵，因此价格越高降价越多，自然买家只会不改变购买数量或者买更多的数量。这样要么收益增加，要么收益大于 $"rev"(tilde(p)) /(1+epsilon)$。

==== 步骤3 : 引理 A.3 从无穷个卖家定价函数中用算法 1 选出的数量够少

只要满足 $n>m$ 的前提， $|overline(P)| <= (frac(e N,m))^m dot (e ceil(2+epsilon) ceil(log_(1+epsilon)(1/epsilon)))^m $

证明方法就是排列组合嗯造，先列求和公式，假设函数有 i 个跳跃点，每个跳跃点是在 $|N-1|$ 的组合数。跳跃点的取值就是 $|W|$ 个已知值域的组合。

$|overline(cal(P))| = sum_(i=1)^m C_i^(N-1) C_i^(|W|)$

因为以下式子展开之后显然包含了以上式子加上某个正数，所以显然有

$|overline(cal(P))| <= (sum_(i=1)^(m) C_i^(N-1)) (sum_(i=1)^(m) C_i^(|W|)) $

$<= (sum_(i=0)^(m) C_i^(N-1)) (sum_(i=0)^(m) C_i^(|W|)) $

利用组合数不等式放缩：

$<= (frac(e (N-1),m))^m dot (frac(e |W|,m))^m $

由 $W$ 的定义，$ceil(log_(1+epsilon)(1/epsilon))$ 个 $Z_i$ 每个切分为 $ceil(2+epsilon)$ 个点，所以 $|W|$ 至多为 $ceil(2+epsilon) ceil(log_(1+epsilon)(1/epsilon))$。

$<= (frac(e (N-1),m))^m dot (e ceil(2+epsilon) ceil(log_(1+epsilon)(1/epsilon)))^m $

==== 步骤 4 ：定理 3.1 成立

综上所述：
$"rev"(p') >= frac("rev"(tilde(p)),1+epsilon) >= frac("OPT" - epsilon,1+epsilon)$

由于卖数据收入的值域为 $[0,1]$，所以 $"OPT"$ 也在 $[0,1]$，所以 $epsilon >= epsilon "OPT" $。

两边都加上 $"OPT" - 2 epsilon$

$"OPT" - epsilon >="OPT" +  epsilon "OPT" - 2 epsilon$

除 $1+epsilon$

$"rev"(p') >= frac("OPT" - epsilon,1+epsilon) >= "OPT" - frac(2 epsilon,1+epsilon) = "OPT" - cal(O)(epsilon)$

由于 $log_(1+epsilon)(1/epsilon) << frac(1,epsilon) $，所以 $|overline(P)| in tilde(O)((N/epsilon)^m)$，因为 $(frac(e (N-1),m))^m dot (e ceil(2+epsilon) ceil(log_(1+epsilon)(1/epsilon)))^m $中，$(frac(e (N-1),m))^m$ 放缩为 $N^m$，$(e ceil(2+epsilon) ceil(log_(1+epsilon)(1/epsilon)))^m$ 放缩为  $epsilon^(-m)$，所以  $|overline(P)| in tilde(O)((N/epsilon)^m)$。

=== 加上平滑性的性质


=== 加上边际效用递减的性质




= Algorithm Specification



= Experiments and Results


== Algorithm Implementation


== Test Case Generation


== Results and Analysis



= Conclusion


